<?

// cls :: obj - object class definition
// --------------------------------------------------------------------------------------
   class obj
   {
   // fnc :: auto - assign array/object keys to self on `new`
   // -----------------------------------------------------------------------------------
      function __construct($atr=null)
      {
         $atr = ((!is_array($atr) && !is_object($atr)) ? [] : $atr);

         foreach ($atr as $key => $val)
         { $this->$key = $val; }
      }
   // -----------------------------------------------------------------------------------

   // fnc :: auto - call to closure (function) on instance of self
   // -----------------------------------------------------------------------------------
      public function __call($pty, $arg)
      {
      // def :: vars - locals
      // --------------------------------------------------------------------------------
         $err = (!property_exists($this,$pty) ? Udf : (!is::fnc($this->$pty) ? Unc : null));
         $itm = debug_backtrace()[0];
      // --------------------------------------------------------------------------------


      // add :: stack - called item
      // --------------------------------------------------------------------------------
         core::stack
         ([
            'file'=>$itm['file'],
            'line'=>$itm['line'],
            'call'=>'obj::'.$pty,
            'args'=>$arg
         ]);
      // --------------------------------------------------------------------------------


      // cnd :: fail - on uncallable
      // --------------------------------------------------------------------------------
         if ($err !== null)
         {
            $apn = SRB.$pty.SRE;
            $err = (!property_exists($this,$apn) ? Udf : (!is::fnc($this->$apn) ? Unc : null));

            if ($err === null)
            { $pty = $apn; }
            else
            { fail::{Ref}("`$pty` is $err"); }
         }
      // --------------------------------------------------------------------------------


      // add :: this - as last item to arguments - not first
      // --------------------------------------------------------------------------------
         $arg[] = $this;
      // --------------------------------------------------------------------------------

      // rsl :: run - closure with args as array
      // --------------------------------------------------------------------------------
         return call_user_func_array($this->$pty, $arg);
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------
   }
// --------------------------------------------------------------------------------------




// is :: type testing
// --------------------------------------------------------------------------------------
   class is
   {
      public static function type($dfn)
      {
         $tpe = strtolower(gettype($dfn));
         $rsl = false;

         if ($tpe === 'string')
         {
            $flc = mb_substr($dfn,0,1).mb_substr($dfn,-1,1);
            $rsl = (($flc === LTB.LTE) ? true : false);
         }

         return $rsl;
      }

      public static function __callStatic($k,$v)
      {
         if (mb_strpos($k,LTB) === false)
         {

            $c = core::get('conf.constant');

            if (!isset($c->$k))
            { return false; }

            $k = $c->$k;
         }

         $d = $v[0];
         $s = (isset($v[1]) ? $v[1] : udf);

         return ((typeOf($d,$s) === $k) ? true : false);
      }
   }
// --------------------------------------------------------------------------------------




// cls :: to - type casting
// --------------------------------------------------------------------------------------
   class to
   {
   // str :: string
   // -----------------------------------------------------------------------------------
      public static function str($d)
      {
         $t = typeOf($d);

         if ($t === str) { return $d; }

         if ($d === null) { return 'null'; }
         if ($d === true) { return 'true'; }
         if ($d === false){ return 'false'; }

         if (($t === int) || ($t === flt))
         { return $d.''; }

         if (($t === arr) || ($t === obj))
         {
            $f = ((MODE !== 'live') ? JSON_PRETTY_PRINT : null);
            $r = str_replace('\\/', '/', json_encode($d, $f));

            if ($r === '')
            {
               $f = [null,true,false];
               $s = ['null','true','false'];

               if ($t === arr)
               { $r = arr($d)->swop($f,$s); }
               else
               { $r = obj($d)->swop($f,$s); }

               $r = print_r($r, true);
            }

            return $r;
         }
      }
   // -----------------------------------------------------------------------------------


   // int :: integer
   // -----------------------------------------------------------------------------------
      public static function int($d)
      {
         $t = typeOf($d);

         if ($t === int)
         { return $d; }

         if ($t === nul)
         { return 0; }

         if ($t === str)
         {
            if (is_numeric($d))
            { return ($d * 1); }
            else
            { return null; }
         }

         if ($t === bln)
         { return (($d === true) ? 1 : 0); }

         return null;
      }
   // -----------------------------------------------------------------------------------


   // bln :: boolean
   // -----------------------------------------------------------------------------------
      public static function bln($d)
      {
         $t = typeOf($d);

         if ($t === nul)
         { return false; }

         if ($t === bln)
         { return $d; }

         if ($t === int)
         {
            if ($d === 1){ return true; }
            if ($d === 0){ return false; }
         }

         if ($t === str)
         {
            if ($d === 'true'){ return true; }
            if ($d === 'false'){ return false; }

            if ($d === 'yes'){ return true; }
            if ($d === 'no'){ return false; }

            if ($d === 'on'){ return true; }
            if ($d === 'off'){ return false; }

            if ($d === '1'){ return true; }
            if ($d === '0'){ return false; }
         }

         return null;
      }
   // -----------------------------------------------------------------------------------


   // arr :: array
   // -----------------------------------------------------------------------------------
      public static function arr($d)
      {
         $t = typeOf($d);

         if ($t === nul){ $d = array(); }
         if ($t === obj){ $d = ((array)$d); }

         if (typeOf($d) === arr)
         {
            reset($d);
            return $d;
         }

         return null;
      }
   // -----------------------------------------------------------------------------------


   // obj :: object
   // -----------------------------------------------------------------------------------
      public static function obj($d=null)
      {
         $t = typeOf($d);

         if ($t === obj)
         { return $d; }

         if (($d === null) || ($t === arr))
         { return obj($d); }

         return null;
      }
   // -----------------------------------------------------------------------------------
   }
// --------------------------------------------------------------------------------------




// cls :: rip - class definition
// --------------------------------------------------------------------------------------
   class rip
   {
   // fnc :: auto call static
   // -----------------------------------------------------------------------------------
      public static function __callStatic($ref, $arg)
      {
      // def :: vars - locals
      // --------------------------------------------------------------------------------
         $src = $arg[0];
         $tpe = typeOf($src);
         $fnd = get::{$ref}($src,Map);
         $tof = typeOf($fnd);
         $fnd = (($tof !== arr) ? [$fnd] : $fnd);
      // --------------------------------------------------------------------------------

      // cnd :: rsl - if nothing found return original data
      // --------------------------------------------------------------------------------
         if ($tof === udf)
         { return $src; }
      // --------------------------------------------------------------------------------

      // cnd :: type - `str`
      // --------------------------------------------------------------------------------
         if ($tpe === str)
         { return str_replace($fnd, '', $src); }
      // --------------------------------------------------------------------------------

      // cnd :: type - `arr` or `obj`
      // --------------------------------------------------------------------------------
         if (($tpe === arr) || ($tpe === obj))
         {
            foreach ($fnd as $map)
            {
               $mri = explode('.',$map)[0];

               if ((($tpe === arr) && !isset($src[$mri])) || (($tpe === obj) && !isset($src->$mri)))
               { continue; }

               $src = set::{$map}($src,udf);
            }
         }
      // --------------------------------------------------------------------------------

      // rsl :: return `src`
      // --------------------------------------------------------------------------------
         return $src;
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------
   }
// --------------------------------------------------------------------------------------




// cls :: val - class definition
// --------------------------------------------------------------------------------------
   class val
   {
   // pty :: public - properties
   // -----------------------------------------------------------------------------------
      public $data = null;
      public $type = null;
   // -----------------------------------------------------------------------------------

   // fnc :: auto - assign given arg to self->data
   // -----------------------------------------------------------------------------------
      function __construct($arg=null)
      {
         $this->data = $arg;
         $this->type = typeOf($arg);
      }
   // -----------------------------------------------------------------------------------

   // fnc :: static - instanciate `val` with data
   // -----------------------------------------------------------------------------------
      public static function of($src)
      {
         return new val($src);
      }
   // -----------------------------------------------------------------------------------



   // fnc :: is - comparrisson
   // -----------------------------------------------------------------------------------
      public function is($lst)
      {
      // def :: vars - locals
      // --------------------------------------------------------------------------------
         $lst = (!is::arr($lst) ? [$lst] : $lst);
         $src = $this->data;
      // --------------------------------------------------------------------------------

      // cnd :: loop - check & return
      // --------------------------------------------------------------------------------
         foreach ($lst as $itm)
         {
            if ($itm === $src)
            { return true; }
         }
      // --------------------------------------------------------------------------------

      // rsl :: default - false
      // --------------------------------------------------------------------------------
         return false;
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------



   // fnc :: to - type-cast
   // -----------------------------------------------------------------------------------
      public function to($tpe)
      {
      // rsl :: cast - to type
      // --------------------------------------------------------------------------------
         return to::{$tpe}($this->data);
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------



   // fnc :: has - posession
   // -----------------------------------------------------------------------------------
      public function has($all,$kvo=udf,$fnd=udf)
      {
      // cnd :: def - place arguments in order by identifying `this`
      // --------------------------------------------------------------------------------
         if (($all !== Any) && ($all !== All) && ($kvo === udf))
         {
            $fnd = $all;
            $kvo = Val;
            $all = Any;
         }
         elseif (($all === Key) || ($all === Val) || ($all === Keys) || ($all === Vals))
         {
            $kvo = $all;
            $all = Any;
            $fnd = $kvo;
         }
      // --------------------------------------------------------------------------------

      // cnd :: fail - here if args are invalid
      // --------------------------------------------------------------------------------
         if
         (
            (($all !== Any) && ($all !== All)) || // scrutiny
            (($kvo !== Key) && ($kvo !== Val) && ($kvo !== Keys) && ($kvo !== Vals))
         )
         { fail::{Ref}('invalid arguments, or argument sequence is wrong'); }
      // --------------------------------------------------------------------------------

      // def :: vars - locals
      // --------------------------------------------------------------------------------
         $fnd = (!is::arr($fnd) ? [$fnd] : $fnd);           // list of items
         $src = $this->data;                                // data source
         $tpe = $this->type;                                // data type
         $len = span($fnd);                                 // number of list items
         $has = [];                                         // items found
      // --------------------------------------------------------------------------------

      // run :: loop - on `$lst`
      // --------------------------------------------------------------------------------
         foreach ($fnd as $itm)
         {
         // cnd :: type - find conditionally by data-type
         // -----------------------------------------------------------------------------
            if ($tpe === str)
            {
               $loc = ((mb_strpos($src,$itm) !== false) ? true : false);
            }
            elseif (($tpe === arr) || ($tpe === obj))
            {
               $kvo = (($kvo === Key) ? "$itm:*" : "*:$itm");
               $loc = ((get::{$kvo}($src) !== udf) ? true : false);
            }
         // -----------------------------------------------------------------------------

         // cnd :: located - increment `$has`
         // -----------------------------------------------------------------------------
            if ($loc){ $has[] = 1; }
         // -----------------------------------------------------------------------------
         }
      // --------------------------------------------------------------------------------

      // cnd :: result - count `has` for `any` or `all`
      // --------------------------------------------------------------------------------
         $cnt = count($has);                                // count result

         if ($cnt === $len){ return true; }                 // all was found (Any & All)
         if ($all === All){ return false; }                 // not all found
         if ($cnt > 0){ return true; }                      // some found (Any)

         return false;                                      // nothng found
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------



   // fnc :: get - retrieve contents from data by reference
   // -----------------------------------------------------------------------------------
      public function get($ref,$dat=udf)
      {
      // rsl :: run - `get`
      // --------------------------------------------------------------------------------
         return get::{$ref}($this->data,$dat);
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------



   // fnc :: add - extension
   // -----------------------------------------------------------------------------------
      public function add($dfn)
      {
      // def :: vars - locals
      // --------------------------------------------------------------------------------
         $src = (is::nul($this->data) ? '' : $this->data);  // src `nul` to empty string
         $tpe = $this->type;                                // src data type
         $dtp = typeOf($dfn);                               // dfn data type
      // --------------------------------------------------------------------------------

      // cnd :: fail - on invalid types
      // --------------------------------------------------------------------------------
         if (($tpe !== str) && ($tpe !== arr) && ($tpe !== obj))
         { fail::{Tpe}('can only add to types: `nul`, `str`, `arr`, `obj`'); }

         if (($tpe === obj) && ($dtp !== obj) && ($dtp !== arr))
         { fail::{Tpe}('can only add types: `arr` & `obj` to an object'); }
      // --------------------------------------------------------------------------------

      // cnd :: type - str/nul
      // --------------------------------------------------------------------------------
         if ($tpe === str)
         {
            return $src.to::str($dfn);                      // concat string convert $dfn
         }
      // --------------------------------------------------------------------------------

      // cnd :: type - arr or obj
      // --------------------------------------------------------------------------------
         if (($tpe === arr) || ($tpe === obj))
         {
         // cnd :: type - src is `arr` and  dfn is `arr` or `obj`
         // -----------------------------------------------------------------------------
            if ($tpe === arr)
            {
               if (($dtp === arr) || ($dtp === obj))
               {
                  foreach ($dfn as $key => $val)
                  {
                     if (is_int($key))
                     { $src[] = $val; }
                     else
                     { $src[$key] = $val; }
                  }
               }
               else
               { $src[] = $val; }
            }
            else
            {
               foreach ($dfn as $key => $val)
               { $src->$key = $val; }
            }
         // -----------------------------------------------------------------------------
         }
      // --------------------------------------------------------------------------------

      // rsl :: result - updated `src`
      // --------------------------------------------------------------------------------
         return $src;
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------



   // fnc :: rip - remove
   // -----------------------------------------------------------------------------------
      public function rip($fnd)
      {
      // run :: `rip` on `src` with `fnd`
      // --------------------------------------------------------------------------------
         return rip::{$fnd}($this->data);
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------



   // fnc :: indx - build a key index of value occurrences in `src` of each item in `fnd`
   // -----------------------------------------------------------------------------------
      public function indx($fnd)
      {
      // def :: vars - locals
      // --------------------------------------------------------------------------------
         $src = $this->data;
         $tpe = $this->type;
         $fnd = (!is_array($fnd) ? [$fnd] : $fnd);
         $rsl = [];
      // --------------------------------------------------------------------------------

      // cnd :: fail - on type mismatch
      // --------------------------------------------------------------------------------
         if (($tpe !== str) && ($tpe !== arr) && ($tpe !== obj))
         { fail::{Tpe}('can only find `indx` on types: `str`, `arr`, `obj`'); }
      // --------------------------------------------------------------------------------

      // cnd :: type - `str`
      // --------------------------------------------------------------------------------
         if ($tpe === str)
         {
            $pos = 0;

            foreach ($fnd as $itm)
            {
               while (($pos = mb_strpos($src, $itm, $pos))!== false)
               {
                  $rsl[] = $pos;
                  $pos = $pos + mb_strlen($itm);
               }
            }

            return $rsl;
         }
      // --------------------------------------------------------------------------------

      // cnd :: type - `arr` or `obj`
      // --------------------------------------------------------------------------------
         if (($tpe === arr) || ($tpe === obj))
         {
            foreach ($fnd as $itm)
            {
               foreach ($src as $key => $val)
               {
                  if ($val === $itm)
                  { $rsl[] = $key; }
               }
            }

            return $rsl;
         }
      // --------------------------------------------------------------------------------

      // rsl :: result - `udf`
      // --------------------------------------------------------------------------------
         return udf;
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------



   // fnc :: swop - replace
   // -----------------------------------------------------------------------------------
      public function swop($fnd,$rpl)
      {
      // def :: vars - locals
      // --------------------------------------------------------------------------------
         $src = $this->data;
         $tpe = $this->type;
      // --------------------------------------------------------------------------------


      // cnd :: type - `str`
      // --------------------------------------------------------------------------------
         if ($tpe === str)
         { return str_replace($fnd, $rpl, $src); }
      // --------------------------------------------------------------------------------

      // cnd :: type - `arr` or `obj`
      // --------------------------------------------------------------------------------
         if (($tpe === arr) || ($tpe === obj))
         {
            $fnd = (!is::arr($fnd) ? [$fnd] : $fnd);
            $rpl = (!is::arr($rpl) ? [$rpl] : $rpl);

            if (count($fnd) !== count($rpl))
            { fail::{src}('pairing mismatch'); }

            foreach($src as &$val)
            {
               $tov = typeOf($val);

               if (($tov === arr) || ($tov === obj))
               {
                  $val = val::of($val)->swop($fnd,$rpl);
               }
               else
               {
                  foreach ($fnd as $idx => $fvl)
                  {
                     if ($val === $fvl)
                     { $val = $rpl[$idx]; }
                  }
               }
            }

            return $src;
         }
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------



   // fnc :: chop - split
   // -----------------------------------------------------------------------------------
      public function chop($dfn)
      {
      // def :: vars - locals
      // --------------------------------------------------------------------------------
         $dfn = ((!$dfn || ($dfn === '')) ? 1 : $dfn);
         $tpe = typeOf($dfn);
         $src = $this->data;
      // --------------------------------------------------------------------------------

      // cnd :: fail - if invalid types
      // --------------------------------------------------------------------------------
         if ($this->type !== str)
         { fail::{Tpe}('can only `chop` on type: `str`'); }

         if (($tpe !== str) && ($tpe !== int))
         { fail::{Tpe}('can only `chop` with types: `str` & `int`'); }
      // --------------------------------------------------------------------------------

      // cnd :: type - `str`
      // --------------------------------------------------------------------------------
         if ($tpe === str)
         { return explode($dfn, $src); }
      // --------------------------------------------------------------------------------

      // cnd :: type - `int`
      // --------------------------------------------------------------------------------
         if ($tpe === int)
         { return str_split($src, $dfn); }
      // --------------------------------------------------------------------------------

      // rsl :: default - `src`
      // --------------------------------------------------------------------------------
         return $src;
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------



   // fnc :: trim - bgn & end of `dfn` by: null, `str`, `int` & by direction: `<<` `>>`
   // -----------------------------------------------------------------------------------
      public function trim($dfn=null,$arw=null)
      {
      // def :: place - arguments
      // --------------------------------------------------------------------------------
         if (($dfn === '>>') || ($dfn === '<<'))
         {
            $tmp = $arw;
            $arw = $dfn;
            $dfn = $tmp;
         }
      // --------------------------------------------------------------------------------

      // def :: vars - locals
      // --------------------------------------------------------------------------------
         $src = $this->data;
         $tpe = $this->type;
         $dtp = typeOf($dfn);
      // --------------------------------------------------------------------------------

      // cnd :: fail - if invalid types
      // --------------------------------------------------------------------------------
         if ($tpe !== str)
         { fail::{Tpe}('can only `trim` on type: `str`'); }

         if (($dtp !== nul) && ($dtp !== str) && ($dtp !== int))
         { fail::{Tpe}('can only `trim` with types: `nul`, `str`, `int`'); }
      // --------------------------------------------------------------------------------

      // cnd :: types - `nul` & `str`
      // --------------------------------------------------------------------------------
         if (($dtp === nul) || ($dtp === str))
         {
            if ($arw === null){ return mb_trim_be($src,$dfn); }   // both
            if ($arw === '<<'){ return mb_trim_bo($src,$dfn); }   // left
            if ($arw === '>>'){ return mb_trim_eo($src,$dfn); }   // right
         }
      // --------------------------------------------------------------------------------

      // cnd :: type - `int` (trim)
      // --------------------------------------------------------------------------------
         if ($dtp === int)
         {
            $a = $arw;
            $s = $src;
            $c = (($dfn < 0) ? true : false);
            $d = ($c ? ($dfn * -1) : $dfn);
            $n = (0 - $d);
            $l = mb_strlen($src);

            $crb = mb_substr($s,0,$d).mb_substr($s,$n,$l);
            $crb = (($d >= $l) ? '' : $crb);

            if ($a === null){ return ($c ? $crb : mb_substr($s,$d,$n)); }
            if ($a === '<<'){ return ($c ? mb_substr($s,0,$d) : mb_substr($s,$d,$l)); }
            if ($a === '>>'){ return ($c ? mb_substr($s,$n,$l) : mb_substr($s,0,$n)); }
         }
      // --------------------------------------------------------------------------------

      // rsl :: default - `src`
      // --------------------------------------------------------------------------------
         return $src;
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------
   }
// --------------------------------------------------------------------------------------




// get :: retrieve value from given argument
// --------------------------------------------------------------------------------------
   class get
   {
   // fnc :: auto call static
   // -----------------------------------------------------------------------------------
      public static function __callStatic($cmd, $arg)
      {
      // locals :: get first argument as argument
      // --------------------------------------------------------------------------------
         $dfn = $arg[0];                                    // definition
         $tpe = typeOf($dfn);                               // type
         $dat = (isset($arg[1]) ? $arg[1] : udf);           // data
         $rsl = [];                                         // result
      // --------------------------------------------------------------------------------


      // null :: nothing to do
      // --------------------------------------------------------------------------------
         if ((span($cmd) < 1) || (span($dfn) < 1))
         { return udf; }
      // --------------------------------------------------------------------------------


      // str
      // --------------------------------------------------------------------------------
         if ($tpe === str)
         {
            if ((mb_strpos($dfn,CRB) === 0) && (mb_strpos($dfn,CRE) === (mb_strlen($dfn) -1)))
            {
               $cls = mb_substr($dfn,1,-1);

               if (!defined($cls))
               { core::load($cls); }

               return $cls::get($cmd,$dat);
            }
            else
            {
            // boundary
            // --------------------------------------------------------------------------
               switch ($cmd)
               {
                  case '<>' : return mb_substr($dfn,0,1).mb_substr($dfn,-1,1);
                  case '><' : return mb_substr($dfn,1,-1);
                  case '<<' : return mb_substr($dfn,0,1);
                  case '>>' : return mb_substr($dfn,-1,1);
               }
            // --------------------------------------------------------------------------


            // extract
            // --------------------------------------------------------------------------
               if ((mb_strpos($cmd, '<-') !== false) || (mb_strpos($cmd, '->') !== false))
               {
               // common locals
               // -----------------------------------------------------------------------
                  $lpa = '<-';
                  $rpa = '->';
                  $lpp = mb_strpos($cmd, $lpa);
                  $rpp = mb_strpos($cmd, $rpa);
                  $len = mb_strlen($dfn);
               // -----------------------------------------------------------------------

               // both inclusion and exclusion
               // -----------------------------------------------------------------------
                  if (($lpp !== false) && ($rpp !== false))
                  {
                  // preparation locals
                  // --------------------------------------------------------------------
                     $inc = (($rpp < $lpp) ? true : false);
                     $lpt = explode($lpa, explode($rpa,$cmd)[($inc ? 1 : 0)]);
                     $rpt = explode($rpa, explode($lpa,$cmd)[($inc ? 0 : 1)]);
                     $cpt = ($inc ? [$rpt[0],$rpt[1],$lpt[1]] : [$lpt[0],$lpt[1],$rpt[1]]);
                     $pos = [null, null];
                     $bfr = '';
                     $rcd = 0;
                     $dlm = DLM;
                     $rsl = [];
                  // --------------------------------------------------------------------

                  // named exclusion
                  // --------------------------------------------------------------------
                     if ((!$inc) && ($cpt[1] !== ''))
                     { return explode(implode($cpt,''), $str); }
                  // --------------------------------------------------------------------

                  // build result list
                  // --------------------------------------------------------------------
                     for ($i=0; $i<$len; $i++)
                     {
                        $bfr .= $dfn[$i];

                        if (($rcd < 1) && (mb_strpos($bfr, $cpt[0]) !== false))
                        {
                           $rcd = 1;
                           $pos[0] = ($i +1);
                           $bfr = '';
                        }

                        if (($rcd > 0) && (mb_strpos($bfr, $cpt[2]) !== false))
                        {
                           $rcd = 0;
                           $pos[1] = ($i);
                           $bfr = '';
                        }

                        if (($pos[0] !== null) && ($pos[1] !== null))
                        {
                           $chk = mb_substr($dfn, $pos[0], ($pos[1] - $pos[0]));

                           $rsl[] = $chk;
                           $pos = [null, null];
                        }
                     }
                  // --------------------------------------------------------------------

                  // inclusion -><-
                  // --------------------------------------------------------------------
                     if ($inc)
                     {
                        if ($cpt[1] === '')
                        { return $rsl; }

                        $tmp = [];

                        foreach ($rsl as $itm)
                        {
                           if ($itm === $cpt[1])
                           { $tmp[] = $itm; }
                        }

                        return ((count($tmp) > 0) ? $tmp : udf);
                     }
                  // --------------------------------------------------------------------

                  // exclusion <-->
                  // --------------------------------------------------------------------
                     foreach ($rsl as $itm)
                     {
                        $itm = $cpt[0].$itm.$cpt[2];
                        $dfn = str_replace($itm, $dlm, $dfn);
                     }

                     $tmp = explode($dlm,$dfn);
                     $rsl = [];

                     foreach ($tmp as $itm)
                     {
                        if (!$itm || (mb_strlen($itm) < 1))
                        { continue; }

                        $rsl[] = $itm;
                     }

                     return ((count($rsl) > 0) ? $rsl : udf);
                  // --------------------------------------------------------------------
                  }
               // -----------------------------------------------------------------------


               // direction of select <- || ->
               // -----------------------------------------------------------------------
                  if (($lpp === 0) || ($rpp === (mb_strlen($cmd) - 2)))
                  {
                     $arw = (($lpp === false) ? $rpa : $lpa);
                     $dlm = str_replace($arw, '', $cmd);
                     $rsl = explode($dlm, $dfn);

                     if (is_numeric($dlm))
                     {
                        $dlm = intval($dlm * 1);

                        if ($arw === $rpa)
                        { return mb_substr($dfn, $dlm, $len); }

                        return udf;
                     }
                     else
                     {
                        if ($arw === $lpa)
                        { array_pop($rsl); }
                        else
                        { array_shift($rsl); }
                     }

                     return ((span($rsl) > 0) ? $rsl : udf);
                  }
               // -----------------------------------------------------------------------


               // default
               // -----------------------------------------------------------------------
                  return udf;
               // -----------------------------------------------------------------------
               }
            // --------------------------------------------------------------------------
            }
         }
      // --------------------------------------------------------------------------------


      // obj or arr
      // --------------------------------------------------------------------------------
         if (($tpe === obj) || ($tpe === arr))
         {
         // reset
         // -----------------------------------------------------------------------------
            reset($dfn);
         // -----------------------------------------------------------------------------


         // sel :: <<  >>  <>  ><
         // -----------------------------------------------------------------------------
            $sel = ['<<','>>','<>','><'];

            if (in_array($cmd,$sel))
            {
               $fst = obj(['key'=>key($dfn), 'val'=>$dfn[key($dfn)]]);
               end($dfn);
               $lst = obj(['key'=>key($dfn), 'val'=>$dfn[key($dfn)]]);
               reset($dfn);

               if (($cmd === '<<') || ($cmd === '>>'))
               {
                  $wrd = (($cmd === '<<') ? 'fst' : 'lst');

                  switch ($dat)
                  {
                     case Key : return ${$wrd}->key;
                     case Obj : return ${$wrd};
                     case Arr : return (array)${$wrd};
                     default  : return ${$wrd}->val;
                  }
               }

               if ($cmd === '<>')
               {
                  if (($dat === Nul) || ($dat === Val))
                  { return [$fst->val, $lst->val]; }

                  if ($dat === Key)
                  { return [$fst->key, $lst->key]; }

                  if (($dat === Arr) || ($dat === Obj))
                  {
                     $rsl[$fst->key] = $fst->val;
                     $rsl[$lst->key] = $lst->val;

                     if ($dat === Obj)
                     { $rsl = obj($rsl); }

                     return $rsl;
                  }
               }

               if ($cmd === '><')
               {
                  if ($tpe === arr)
                  { array_shift($dfn); array_pop($dfn); }
                  else
                  { unset($dfn->{$fst->key}); unset($dfn->{$lst->key}); }

                  if ($dat === Arr)
                  { return (array)$dfn; }
                  elseif ($dat === Obj)
                  { return obj($dfn); }
                  else
                  {
                     foreach ($dfn as $key => $val)
                     {
                        if ($dat === Key)
                        { $rsl[] = $key; }
                        else
                        { $rsl[] = $val; }
                     }

                     return $rsl;
                  }
               }
            }
         // -----------------------------------------------------------------------------


         // map :: key.key.key.etc
         // -----------------------------------------------------------------------------
            if (strpos($cmd, ':') === false)
            {
               if (strpos($cmd,'..') !== false)
               { return udf; }

               $map = explode('.',$cmd);
               $src = $dfn;
               $obj = &$dfn;

               foreach ($map as $key)
               {
                  $tpe = typeOf($obj);
                  $key = (is_numeric($key) ? ($key * 1) : $key);
                  $fkn = SRB.$key.SRE;

                  if (($tpe === obj) && isset($obj->$key))
                  { $obj = $obj->$key; }
                  elseif (($tpe === obj) && isset($obj->$fkn))
                  { $obj = $obj->$fkn; }
                  elseif (($tpe === arr) && isset($obj[$key]))
                  { $obj = $obj[$key]; }
                  elseif (($tpe === arr) && isset($obj[$fkn]))
                  { $obj = $obj[$fkn]; }
                  else
                  { return udf; }
               }

               if ($dat === Map)
               { return $cmd; }

               $tpe = typeOf($obj);

               if (($dat === Keys) || ($dat === Key))
               {
                  if (($tpe === arr) || ($tpe === obj))
                  { return array_keys($obj); }
                  else
                  { return get::{":$obj"}($src,$dat); }
               }

               if (($dat === Vals) || ($dat === Val))
               {
                  $rsl = [];

                  if (($tpe === arr) || ($tpe === obj))
                  {
                     foreach ($obj as $key => $val)
                     { $rsl[] = $val; }
                  }
                  else
                  {
                     if ($dat === Vals)
                     { $rsl[] = $obj; }
                     else
                     { $rsl = $obj; }
                  }

                  return $rsl;
               }

               return $obj;
            }
         // -----------------------------------------------------------------------------


         // fnd :: {key:val}
         // -----------------------------------------------------------------------------
            if (strpos($cmd, ':') !== false)
            {
               $pts = explode(':', $cmd);
               $key = ((span($pts[0]) < 1) ? '*' : $pts[0]);
               $val = ((span($pts[1]) < 1) ? '*' : $pts[1]);

               $fnd = obj
               ([
                  'key'=>((($key !== '*') && (strpos($key, '*') !== false)) ? true : false),
                  'val'=>((($val !== '*') && (strpos($val, '*') !== false)) ? true : false),
               ]);

               $fnd = ((($fnd->key === false) && ($fnd->val === false)) ? false : $fnd);
               $val = (is_numeric($val) ? ($val * 1) : $val);


               foreach ($dfn as $k => $v)
               {
                  $tov = typeOf($v);                     // value data type
                  $kdm = (($key === '*') ? $k : $key);   // key data match
                  $vdm = (($val === '*') ? $v : $val);   // val data match

                  if ($fnd !== false)
                  {
                     foreach ($fnd as $fin => $fav)
                     {
                        if ($fav !== false)
                        {
                           if (($fin === 'val') && ($tov !== str))
                           { continue; }

                           ${$fin[0].'dm'} = udf;

                           $str = str_replace('*','',${$fin});
                           $len = strlen($str);
                           $sub = [strpos(${$fin[0]}, $str),$len];

                           if ((substr_count(${$fin},'*') < 2) && (strpos(${$fin},'*') === $len))
                           { $sub = [0,$len]; }

                           if (substr(${$fin[0]}, $sub[0], $sub[1]) === $str)
                           { ${$fin[0].'dm'} = ${$fin[0]}; }
                        }
                     }
                  }

                  if (($k === $kdm) && ($v === $vdm))
                  {
                     switch ($dat)
                     {
                        case Keys : $r = $k; break;

                        case Key : $r = $k; break;
                        case Obj : $r = obj([$k=>$v]); break;
                        case Arr : $r = [$k=>$v]; break;
                        case Map : $r = $k; break;
                        default  : $r = $v;
                     }

                     if (($dat === Keys) || ($dat === Vals) || ($fnd !== false))
                     { $rsl[] = $r; }
                     else
                     { return $r; }
                  }
                  else
                  {
                     if (($tov == obj) || ($tov == arr))
                     {
                        $r = get::{"$key:$val"}($v,$dat);
                        $t = typeOf($r);

                        if ($r !== udf)
                        {
                           if ($t === arr)
                           {
                              foreach ($r as $d)
                              {
                                 if ($dat !== Map)
                                 { $rsl[] = $d; }
                                 else
                                 { $rsl[] = "$k.$d"; }
                              }
                           }
                           else
                           {
                              if ($dat !== Map)
                              { return $r; }
                              else
                              { return "$k.$r"; }
                           }
                        }
                     }
                  }
               }
            }
         // -----------------------------------------------------------------------------
         }
      // --------------------------------------------------------------------------------


      // result
      // --------------------------------------------------------------------------------
         return ((count($rsl) > 0) ? $rsl : udf);
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------
   }
// --------------------------------------------------------------------------------------




// set :: dynamically create classes
// --------------------------------------------------------------------------------------
   class set
   {
   // set :: {map}(src/val, val)
   // -----------------------------------------------------------------------------------
      public static function __callStatic($map, $atr)
      {
      // def :: dissect - src & val
      // --------------------------------------------------------------------------------
         if (array_key_exists(1, $atr))
         {
         // src & val is given in atr
         // -----------------------------------------------------------------------------
            $src = $atr[0];                                 // src is atr[0]
            $val = $atr[1];                                 // val is atr[1]
         // -----------------------------------------------------------------------------
         }
         else
         {
         // src is in map, val is given in atr
         // -----------------------------------------------------------------------------
            $pts = explode('.',$map);                       // get map parts
            $cls = array_shift($pts);                       // first item is class name
            $map = implode($pts,'.');                       // map is remainder
            $val = $atr[0];                                 // val is atr[0]

            return $cls::set($map,$val);
         // -----------------------------------------------------------------------------
         }
      // --------------------------------------------------------------------------------


      // validate
      // --------------------------------------------------------------------------------
         $tpe = typeOf($src);

         if (strpos($map,'..') !== false)
         { fail::{Ref}('cannot create an empty key-names'); }

         if (($tpe !== obj) && ($tpe !== arr))
         { fail::{Ref}("cannot create map on type: `$tpe`"); }
      // --------------------------------------------------------------------------------


      // def :: locals
      // --------------------------------------------------------------------------------
         $map = explode('.', $map);                         // map parts
         $tov = typeOf($val);                               // type of value
         $lmi = $map[(count($map) -1)];                     // last map item
         $rsl =& $src;                                      // src link result
      // --------------------------------------------------------------------------------


      // run :: loop - through each map item, creating map
      // --------------------------------------------------------------------------------
         foreach ($map as $itm)
         {
         // cnd :: rip - if `val` is `udf`
         // -----------------------------------------------------------------------------
            if (($itm === $lmi) && ($val === udf))
            {
               if (isset($rsl->$itm))
               { unset($rsl->$itm); }

               continue;
            }
         // -----------------------------------------------------------------------------

         // numeric keys
         // -----------------------------------------------------------------------------
            if (is_numeric($itm))
            { $itm = ($itm * 1); }
         // -----------------------------------------------------------------------------

         // set :: locals
         // -----------------------------------------------------------------------------
            $tpe = typeOf($rsl);
            $key = ((($itm === $lmi) && ($tov == fnc)) ? SRB.$itm.SRE : $itm);
         // -----------------------------------------------------------------------------

         // cnd :: type - obj
         // -----------------------------------------------------------------------------
            if ($tpe == obj)
            {
               if (!isset($rsl->$key) && ($val !== udf))
               { $rsl->$key = obj(); }

               $rsl =& $rsl->$key; continue;
            }
         // -----------------------------------------------------------------------------

         // cnd :: type - arr
         // -----------------------------------------------------------------------------
            if ($tpe == arr)
            {
               if (!isset($rsl[$key]) && ($val !== udf))
               { $rsl[$key] = obj(); }

               $rsl =& $rsl[$key]; continue;
            }
         // -----------------------------------------------------------------------------
         }
      // --------------------------------------------------------------------------------

      // rsl :: set & return
      // --------------------------------------------------------------------------------
         if ($val !== udf)
         { $rsl = $val; }

         return $src;
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------
   }
// --------------------------------------------------------------------------------------

?>
