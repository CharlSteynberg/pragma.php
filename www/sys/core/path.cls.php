<?

// cls :: path - class definition
// --------------------------------------------------------------------------------------
   class path
   {
   // pty :: locals
   // -----------------------------------------------------------------------------------
      private static $attr = 0;                             // attributes
   // -----------------------------------------------------------------------------------


   // fnc :: init - initialize path
   // -----------------------------------------------------------------------------------
      public static function init()
      {
         self::$attr = new stdClass();                      // attrinutes object
         self::$attr->conf = json_decode(file_get_contents('cfg/path/_auto.cfg.jso'));
      }
   // -----------------------------------------------------------------------------------


   // fnc :: norm - normalize paths
   // -----------------------------------------------------------------------------------
      public static function norm($pth)
      {
      // cnd :: fail - on invalid path
      // --------------------------------------------------------------------------------
         if (!is::str($pth) || (typeOf($pth,str) !== PTH))
         { fail::{Tpe}('type: `string-path` expected'); }
      // --------------------------------------------------------------------------------

      // set :: prep - make `$pth` uniform
      // --------------------------------------------------------------------------------
         $pth = str_replace(CWD, '', $pth);                 // force relative path
         $pth = (($pth[0] === '/') ? 'pub'.$pth : $pth);    // first char `/` means pub
         $pth = ltrim($pth,'.');                            // remove preceeding `.`
         $pth = rtrim($pth,'/');                            // remove trailing `/`
      // --------------------------------------------------------------------------------

      // rsl :: return - `$pth`
      // --------------------------------------------------------------------------------
         return $pth;
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------



   // fnc :: info - path information
   // -----------------------------------------------------------------------------------
      public static function info($pth)
      {
      // cnd :: fail - on invalid path
      // --------------------------------------------------------------------------------
         $pth = self::norm($pth);
      // --------------------------------------------------------------------------------


      // def :: local - vars
      // --------------------------------------------------------------------------------
         $apn = CWD.$pth;
         $pts = explode('/', $pth);
         $bse = array_pop($pts);
         $pts = ((count($pts) < 1) ? [SHD] : $pts);
         $inf = (object)pathinfo($pth);
         $fnm = (isset($inf->filename) ? $inf->filename : $bse);
         $ext = (isset($inf->extension) ? $inf->extension : udf);
         $sts = ((!is_readable($apn) ? (!file_exists($apn) ? 404 : 403) : 200));
         $tpe = 'none';
         $sze = 0;
         $mme = path::get('conf.mime');
         $mme = (isset($mme->$ext) ? $mme->$ext : udf);
         $enc = udf;
         $bnr = udf;
      // --------------------------------------------------------------------------------


      // def :: cnd - if exist
      // --------------------------------------------------------------------------------
         if ($sts < 300)
         {
            $tpe = (is_file($apn) ? 'file' : (is_dir($apn) ? 'dir' : (is_link($apn) ? 'link' : 'path')));

            if ($tpe === 'file')
            {
               $sze = filesize($apn);

               $flh = fopen(CWD.'/'.$pth, "r");
               $str = fread($flh, 512);
               $flh = fclose($flh); clearstatcache();
               $enc = strtolower(mb_detect_encoding($str, mb_list_encodings(), true));
               $bnr = ((($enc === 'ascii') || ($enc === 'utf-8')) ? false : true);
            }
            elseif ($tpe === 'dir')
            {
               $sze = (count(scandir($apn)) - 2);
            }
            elseif ($tpe === 'link')
            {
               $lnk = readlink($apn);
               $sze = ($lnk ? strlen($lnk) : 0);
            }
         }
      // --------------------------------------------------------------------------------


      // rsl :: result - object
      // --------------------------------------------------------------------------------
         return obj
         ([
            'stat'=>(($sts > 300) ? $sts : (($sze > 0) ? 200 : 204)),
            'type'=>$tpe,
            'path'=>$pth,
            'root'=>$pts[0],
            'home'=>((count($pts) > 1) ? implode($pts, '/') : SHD),
            'base'=>$bse,
            'name'=>$fnm,
            'extn'=>$ext,
            'mime'=>$mme,
            'size'=>(($sts === 404) ? udf : $sze),
            'char'=>$enc,
            'bnry'=>$bnr,
         ]);
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------



   // fnc :: make - safely create `path/to/dir-or-file` recursively (does NOT over-write)
   // -----------------------------------------------------------------------------------
      public static function make($pth, $dat='')
      {
      // add :: to - call-stack
      // --------------------------------------------------------------------------------
         core::stack();
      // --------------------------------------------------------------------------------


      // def :: vars - locals
      // --------------------------------------------------------------------------------
         $pth = path::norm($pth);
         $pts = explode('/',$pth);
         $fst = array_shift($pts);
         $dir = $fst;
      // --------------------------------------------------------------------------------


      // set :: umask - temp
      // --------------------------------------------------------------------------------
         $msk = umask(0);
      // --------------------------------------------------------------------------------


      // run :: loop - iterate through parts
      // --------------------------------------------------------------------------------
         foreach ($pts as $itm)
         {
         // cnd :: dir - item does NOT contain `.`
         // -----------------------------------------------------------------------------
            if (strpos($itm,'.') === false)
            {
            // def :: target - sequence
            // --------------------------------------------------------------------------
               $pvs = $dir;
               $dir .= "/$itm";
            // --------------------------------------------------------------------------

            // cnd :: only - if dir does NOT exist
            // --------------------------------------------------------------------------
               if (!file_exists(CWD.$dir))
               {
               // cnd :: fail - if parent not writable
               // -----------------------------------------------------------------------
                  if (!is_writable(CWD.$pvs))
                  {
                     $pvs = (($pvs === '') ? '/' : $pvs);
                     fail::{Ref}("`$pvs` is not writable");
                  }
               // -----------------------------------------------------------------------

               // run :: create dir
               // -----------------------------------------------------------------------
                  mkdir(CWD.$dir,0777);
               // -----------------------------------------------------------------------
               }
            // --------------------------------------------------------------------------

            // fwd :: skip - condition below
            // --------------------------------------------------------------------------
               continue;
            // --------------------------------------------------------------------------
            }
         // -----------------------------------------------------------------------------


         // cnd :: file - contains `.`
         // -----------------------------------------------------------------------------
            if (strpos($itm,'.') !== false)
            {
            // cnd :: only - if `path/to/file` does NOT exist
            // --------------------------------------------------------------------------
               if (!file_exists(CWD.$pth))
               {
               // cnd :: fail - if dir not writable
               // -----------------------------------------------------------------------
                  if (!is_writable(CWD.$dir))
                  { fail::{Src}("`$dir` is not writable"); }
               // -----------------------------------------------------------------------

               // run :: create file, write `$dat` & chmod
               // -----------------------------------------------------------------------
                  file_put_contents(CWD.$pth, $dat);
                  chmod(CWD.$pth, 0777);
                  break;
               // -----------------------------------------------------------------------
               }
            // --------------------------------------------------------------------------
            }
         // -----------------------------------------------------------------------------
         }
      // --------------------------------------------------------------------------------


      // set :: umask - restore
      // --------------------------------------------------------------------------------
         umask($msk);
      // --------------------------------------------------------------------------------


      // rsl :: return - true
      // --------------------------------------------------------------------------------
         return true;
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------



   // fnc :: read - with vars as data-type, or as data for parsing
   // -----------------------------------------------------------------------------------
      public static function read($pth, $vrs=udf)
      {
      // add :: to - call-stack
      // --------------------------------------------------------------------------------
         core::stack();
      // --------------------------------------------------------------------------------


      // def :: vars - locals
      // --------------------------------------------------------------------------------
         $pth = dbug::path($pth);
         $inf = path::info($pth);
         $apn = CWD.$pth;
         $tov = typeOf($vrs);
      // --------------------------------------------------------------------------------


      // cnd :: size - return null on empty
      // --------------------------------------------------------------------------------
         if ($inf->size < 1)
         { return null; }
      // --------------------------------------------------------------------------------


      // cnd :: type - `dir`
      // --------------------------------------------------------------------------------
         if ($inf->type === 'dir')
         {
            $lst = scandir($apn); array_shift($lst); array_shift($lst);
            $rsl = [];

            foreach ($lst as $itm)
            { $rsl[] = self::info("$pth/$itm"); }

            if ($vrs === str)
            { return to::str($rsl); }

            return $rsl;
         }
      // --------------------------------------------------------------------------------


      // cnd :: type - `file`
      // --------------------------------------------------------------------------------
         if ($inf->type === 'file')
         {
            $rsl = file_get_contents($apn);

            if ($vrs === udf)
            { return $rsl; }

            if ($vrs === str)
            {
               if ($inf->bnry === false)
               { return $rsl; }

               return "data:$inf->mime;base64,".base64_encode($rsl);
            }

            if (($vrs === auto) || ($tov === obj))
            {
               $vrs = (($tov !== obj) ? obj() : $vrs);

               $vrs->{'$path'} = $pth;

               return cast($rsl,$vrs);
            }

            return $rsl;
         }
      // --------------------------------------------------------------------------------


      // cnd :: type - `link`
      // --------------------------------------------------------------------------------
         if ($inf->type === 'link')
         {
            $rsl = readlink($apn);
            $rsl = ((strpos($rsl, SHD) !== false) ? explode(SHD, $rsl)[1] : $rsl);

            return $rsl;
         }
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------



   // fnc :: find - locate a substring in a file
   // -----------------------------------------------------------------------------------
      public static function find($ndl,$hay)
      {
         $ndl = (!is::arr($ndl) ? [$ndl] : $ndl);
         $hay = (!is::arr($hay) ? [$hay] : $hay);

         $nbr = 0;
         $pos = 0;

         foreach ($hay as $bal)
         {
            $bal = path::norm($bal);

            if (!file_exists(CWD.$bal))
            { continue; }

            $lns = explode("\n", file_get_contents(CWD.$bal));

            foreach ($lns as $nbr => $lne)
            {
               foreach ($ndl as $fnd)
               {
                  dbug::type($fnd, str);

                  $pos = strpos($lne,$fnd);

                  if ($pos !== false)
                  {
                     $nbr += 1;
                     $pos += 1;

                     return [$bal,$nbr,$pos];
                  }
               }
            }
         }

         return null;
      }
   // -----------------------------------------------------------------------------------



   // get :: compatibility
   // -----------------------------------------------------------------------------------
      public static function get($cmd,$dat=null)
      {
      // rsl :: return - get from local `$attr`
      // --------------------------------------------------------------------------------
         return get::{$cmd}(self::$attr,$dat);
      // --------------------------------------------------------------------------------
      }
   // -----------------------------------------------------------------------------------
   }
// --------------------------------------------------------------------------------------


// run :: init - path
// --------------------------------------------------------------------------------------
   path::init();
// --------------------------------------------------------------------------------------


?>
